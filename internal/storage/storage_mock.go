// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package storage

import (
	"context"

	mock "github.com/stretchr/testify/mock"
	"go.flipt.io/flipt/rpc/flipt/core"
	"go.flipt.io/flipt/rpc/v2/evaluation/client"
)

// NewMockReadOnlyStore creates a new instance of MockReadOnlyStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReadOnlyStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReadOnlyStore {
	mock := &MockReadOnlyStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReadOnlyStore is an autogenerated mock type for the ReadOnlyStore type
type MockReadOnlyStore struct {
	mock.Mock
}

type MockReadOnlyStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReadOnlyStore) EXPECT() *MockReadOnlyStore_Expecter {
	return &MockReadOnlyStore_Expecter{mock: &_m.Mock}
}

// CountFlags provides a mock function for the type MockReadOnlyStore
func (_mock *MockReadOnlyStore) CountFlags(ctx context.Context, ns NamespaceRequest) (uint64, error) {
	ret := _mock.Called(ctx, ns)

	if len(ret) == 0 {
		panic("no return value specified for CountFlags")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, NamespaceRequest) (uint64, error)); ok {
		return returnFunc(ctx, ns)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, NamespaceRequest) uint64); ok {
		r0 = returnFunc(ctx, ns)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, NamespaceRequest) error); ok {
		r1 = returnFunc(ctx, ns)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadOnlyStore_CountFlags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountFlags'
type MockReadOnlyStore_CountFlags_Call struct {
	*mock.Call
}

// CountFlags is a helper method to define mock.On call
//   - ctx
//   - ns
func (_e *MockReadOnlyStore_Expecter) CountFlags(ctx interface{}, ns interface{}) *MockReadOnlyStore_CountFlags_Call {
	return &MockReadOnlyStore_CountFlags_Call{Call: _e.mock.On("CountFlags", ctx, ns)}
}

func (_c *MockReadOnlyStore_CountFlags_Call) Run(run func(ctx context.Context, ns NamespaceRequest)) *MockReadOnlyStore_CountFlags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(NamespaceRequest))
	})
	return _c
}

func (_c *MockReadOnlyStore_CountFlags_Call) Return(v uint64, err error) *MockReadOnlyStore_CountFlags_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockReadOnlyStore_CountFlags_Call) RunAndReturn(run func(ctx context.Context, ns NamespaceRequest) (uint64, error)) *MockReadOnlyStore_CountFlags_Call {
	_c.Call.Return(run)
	return _c
}

// EvaluationNamespaceSnapshot provides a mock function for the type MockReadOnlyStore
func (_mock *MockReadOnlyStore) EvaluationNamespaceSnapshot(context1 context.Context, ns string) (*client.EvaluationNamespaceSnapshot, error) {
	ret := _mock.Called(context1, ns)

	if len(ret) == 0 {
		panic("no return value specified for EvaluationNamespaceSnapshot")
	}

	var r0 *client.EvaluationNamespaceSnapshot
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*client.EvaluationNamespaceSnapshot, error)); ok {
		return returnFunc(context1, ns)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *client.EvaluationNamespaceSnapshot); ok {
		r0 = returnFunc(context1, ns)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.EvaluationNamespaceSnapshot)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(context1, ns)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadOnlyStore_EvaluationNamespaceSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EvaluationNamespaceSnapshot'
type MockReadOnlyStore_EvaluationNamespaceSnapshot_Call struct {
	*mock.Call
}

// EvaluationNamespaceSnapshot is a helper method to define mock.On call
//   - context1
//   - ns
func (_e *MockReadOnlyStore_Expecter) EvaluationNamespaceSnapshot(context1 interface{}, ns interface{}) *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call {
	return &MockReadOnlyStore_EvaluationNamespaceSnapshot_Call{Call: _e.mock.On("EvaluationNamespaceSnapshot", context1, ns)}
}

func (_c *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call) Run(run func(context1 context.Context, ns string)) *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call) Return(evaluationNamespaceSnapshot *client.EvaluationNamespaceSnapshot, err error) *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call {
	_c.Call.Return(evaluationNamespaceSnapshot, err)
	return _c
}

func (_c *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call) RunAndReturn(run func(context1 context.Context, ns string) (*client.EvaluationNamespaceSnapshot, error)) *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// GetEvaluationDistributions provides a mock function for the type MockReadOnlyStore
func (_mock *MockReadOnlyStore) GetEvaluationDistributions(ctx context.Context, flag ResourceRequest, rule IDRequest) ([]*EvaluationDistribution, error) {
	ret := _mock.Called(ctx, flag, rule)

	if len(ret) == 0 {
		panic("no return value specified for GetEvaluationDistributions")
	}

	var r0 []*EvaluationDistribution
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ResourceRequest, IDRequest) ([]*EvaluationDistribution, error)); ok {
		return returnFunc(ctx, flag, rule)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ResourceRequest, IDRequest) []*EvaluationDistribution); ok {
		r0 = returnFunc(ctx, flag, rule)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*EvaluationDistribution)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ResourceRequest, IDRequest) error); ok {
		r1 = returnFunc(ctx, flag, rule)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadOnlyStore_GetEvaluationDistributions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEvaluationDistributions'
type MockReadOnlyStore_GetEvaluationDistributions_Call struct {
	*mock.Call
}

// GetEvaluationDistributions is a helper method to define mock.On call
//   - ctx
//   - flag
//   - rule
func (_e *MockReadOnlyStore_Expecter) GetEvaluationDistributions(ctx interface{}, flag interface{}, rule interface{}) *MockReadOnlyStore_GetEvaluationDistributions_Call {
	return &MockReadOnlyStore_GetEvaluationDistributions_Call{Call: _e.mock.On("GetEvaluationDistributions", ctx, flag, rule)}
}

func (_c *MockReadOnlyStore_GetEvaluationDistributions_Call) Run(run func(ctx context.Context, flag ResourceRequest, rule IDRequest)) *MockReadOnlyStore_GetEvaluationDistributions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ResourceRequest), args[2].(IDRequest))
	})
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationDistributions_Call) Return(evaluationDistributions []*EvaluationDistribution, err error) *MockReadOnlyStore_GetEvaluationDistributions_Call {
	_c.Call.Return(evaluationDistributions, err)
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationDistributions_Call) RunAndReturn(run func(ctx context.Context, flag ResourceRequest, rule IDRequest) ([]*EvaluationDistribution, error)) *MockReadOnlyStore_GetEvaluationDistributions_Call {
	_c.Call.Return(run)
	return _c
}

// GetEvaluationRollouts provides a mock function for the type MockReadOnlyStore
func (_mock *MockReadOnlyStore) GetEvaluationRollouts(ctx context.Context, flag ResourceRequest) ([]*EvaluationRollout, error) {
	ret := _mock.Called(ctx, flag)

	if len(ret) == 0 {
		panic("no return value specified for GetEvaluationRollouts")
	}

	var r0 []*EvaluationRollout
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ResourceRequest) ([]*EvaluationRollout, error)); ok {
		return returnFunc(ctx, flag)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ResourceRequest) []*EvaluationRollout); ok {
		r0 = returnFunc(ctx, flag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*EvaluationRollout)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ResourceRequest) error); ok {
		r1 = returnFunc(ctx, flag)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadOnlyStore_GetEvaluationRollouts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEvaluationRollouts'
type MockReadOnlyStore_GetEvaluationRollouts_Call struct {
	*mock.Call
}

// GetEvaluationRollouts is a helper method to define mock.On call
//   - ctx
//   - flag
func (_e *MockReadOnlyStore_Expecter) GetEvaluationRollouts(ctx interface{}, flag interface{}) *MockReadOnlyStore_GetEvaluationRollouts_Call {
	return &MockReadOnlyStore_GetEvaluationRollouts_Call{Call: _e.mock.On("GetEvaluationRollouts", ctx, flag)}
}

func (_c *MockReadOnlyStore_GetEvaluationRollouts_Call) Run(run func(ctx context.Context, flag ResourceRequest)) *MockReadOnlyStore_GetEvaluationRollouts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ResourceRequest))
	})
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationRollouts_Call) Return(evaluationRollouts []*EvaluationRollout, err error) *MockReadOnlyStore_GetEvaluationRollouts_Call {
	_c.Call.Return(evaluationRollouts, err)
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationRollouts_Call) RunAndReturn(run func(ctx context.Context, flag ResourceRequest) ([]*EvaluationRollout, error)) *MockReadOnlyStore_GetEvaluationRollouts_Call {
	_c.Call.Return(run)
	return _c
}

// GetEvaluationRules provides a mock function for the type MockReadOnlyStore
func (_mock *MockReadOnlyStore) GetEvaluationRules(ctx context.Context, flag ResourceRequest) ([]*EvaluationRule, error) {
	ret := _mock.Called(ctx, flag)

	if len(ret) == 0 {
		panic("no return value specified for GetEvaluationRules")
	}

	var r0 []*EvaluationRule
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ResourceRequest) ([]*EvaluationRule, error)); ok {
		return returnFunc(ctx, flag)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ResourceRequest) []*EvaluationRule); ok {
		r0 = returnFunc(ctx, flag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*EvaluationRule)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ResourceRequest) error); ok {
		r1 = returnFunc(ctx, flag)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadOnlyStore_GetEvaluationRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEvaluationRules'
type MockReadOnlyStore_GetEvaluationRules_Call struct {
	*mock.Call
}

// GetEvaluationRules is a helper method to define mock.On call
//   - ctx
//   - flag
func (_e *MockReadOnlyStore_Expecter) GetEvaluationRules(ctx interface{}, flag interface{}) *MockReadOnlyStore_GetEvaluationRules_Call {
	return &MockReadOnlyStore_GetEvaluationRules_Call{Call: _e.mock.On("GetEvaluationRules", ctx, flag)}
}

func (_c *MockReadOnlyStore_GetEvaluationRules_Call) Run(run func(ctx context.Context, flag ResourceRequest)) *MockReadOnlyStore_GetEvaluationRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ResourceRequest))
	})
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationRules_Call) Return(evaluationRules []*EvaluationRule, err error) *MockReadOnlyStore_GetEvaluationRules_Call {
	_c.Call.Return(evaluationRules, err)
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationRules_Call) RunAndReturn(run func(ctx context.Context, flag ResourceRequest) ([]*EvaluationRule, error)) *MockReadOnlyStore_GetEvaluationRules_Call {
	_c.Call.Return(run)
	return _c
}

// GetFlag provides a mock function for the type MockReadOnlyStore
func (_mock *MockReadOnlyStore) GetFlag(ctx context.Context, req ResourceRequest) (*core.Flag, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetFlag")
	}

	var r0 *core.Flag
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ResourceRequest) (*core.Flag, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ResourceRequest) *core.Flag); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Flag)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ResourceRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadOnlyStore_GetFlag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFlag'
type MockReadOnlyStore_GetFlag_Call struct {
	*mock.Call
}

// GetFlag is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *MockReadOnlyStore_Expecter) GetFlag(ctx interface{}, req interface{}) *MockReadOnlyStore_GetFlag_Call {
	return &MockReadOnlyStore_GetFlag_Call{Call: _e.mock.On("GetFlag", ctx, req)}
}

func (_c *MockReadOnlyStore_GetFlag_Call) Run(run func(ctx context.Context, req ResourceRequest)) *MockReadOnlyStore_GetFlag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ResourceRequest))
	})
	return _c
}

func (_c *MockReadOnlyStore_GetFlag_Call) Return(flag *core.Flag, err error) *MockReadOnlyStore_GetFlag_Call {
	_c.Call.Return(flag, err)
	return _c
}

func (_c *MockReadOnlyStore_GetFlag_Call) RunAndReturn(run func(ctx context.Context, req ResourceRequest) (*core.Flag, error)) *MockReadOnlyStore_GetFlag_Call {
	_c.Call.Return(run)
	return _c
}

// ListFlags provides a mock function for the type MockReadOnlyStore
func (_mock *MockReadOnlyStore) ListFlags(ctx context.Context, req *ListRequest[NamespaceRequest]) (ResultSet[*core.Flag], error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ListFlags")
	}

	var r0 ResultSet[*core.Flag]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ListRequest[NamespaceRequest]) (ResultSet[*core.Flag], error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *ListRequest[NamespaceRequest]) ResultSet[*core.Flag]); ok {
		r0 = returnFunc(ctx, req)
	} else {
		r0 = ret.Get(0).(ResultSet[*core.Flag])
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *ListRequest[NamespaceRequest]) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadOnlyStore_ListFlags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListFlags'
type MockReadOnlyStore_ListFlags_Call struct {
	*mock.Call
}

// ListFlags is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *MockReadOnlyStore_Expecter) ListFlags(ctx interface{}, req interface{}) *MockReadOnlyStore_ListFlags_Call {
	return &MockReadOnlyStore_ListFlags_Call{Call: _e.mock.On("ListFlags", ctx, req)}
}

func (_c *MockReadOnlyStore_ListFlags_Call) Run(run func(ctx context.Context, req *ListRequest[NamespaceRequest])) *MockReadOnlyStore_ListFlags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ListRequest[NamespaceRequest]))
	})
	return _c
}

func (_c *MockReadOnlyStore_ListFlags_Call) Return(resultSet ResultSet[*core.Flag], err error) *MockReadOnlyStore_ListFlags_Call {
	_c.Call.Return(resultSet, err)
	return _c
}

func (_c *MockReadOnlyStore_ListFlags_Call) RunAndReturn(run func(ctx context.Context, req *ListRequest[NamespaceRequest]) (ResultSet[*core.Flag], error)) *MockReadOnlyStore_ListFlags_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function for the type MockReadOnlyStore
func (_mock *MockReadOnlyStore) String() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockReadOnlyStore_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type MockReadOnlyStore_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *MockReadOnlyStore_Expecter) String() *MockReadOnlyStore_String_Call {
	return &MockReadOnlyStore_String_Call{Call: _e.mock.On("String")}
}

func (_c *MockReadOnlyStore_String_Call) Run(run func()) *MockReadOnlyStore_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockReadOnlyStore_String_Call) Return(s string) *MockReadOnlyStore_String_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockReadOnlyStore_String_Call) RunAndReturn(run func() string) *MockReadOnlyStore_String_Call {
	_c.Call.Return(run)
	return _c
}
