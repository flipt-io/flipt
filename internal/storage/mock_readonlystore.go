// Code generated by mockery v2.52.1. DO NOT EDIT.

package storage

import (
	context "context"

	core "go.flipt.io/flipt/rpc/flipt/core"
	evaluation "go.flipt.io/flipt/rpc/flipt/evaluation"

	mock "github.com/stretchr/testify/mock"
)

// MockReadOnlyStore is an autogenerated mock type for the ReadOnlyStore type
type MockReadOnlyStore struct {
	mock.Mock
}

type MockReadOnlyStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReadOnlyStore) EXPECT() *MockReadOnlyStore_Expecter {
	return &MockReadOnlyStore_Expecter{mock: &_m.Mock}
}

// CountFlags provides a mock function with given fields: ctx, ns
func (_m *MockReadOnlyStore) CountFlags(ctx context.Context, ns NamespaceRequest) (uint64, error) {
	ret := _m.Called(ctx, ns)

	if len(ret) == 0 {
		panic("no return value specified for CountFlags")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, NamespaceRequest) (uint64, error)); ok {
		return rf(ctx, ns)
	}
	if rf, ok := ret.Get(0).(func(context.Context, NamespaceRequest) uint64); ok {
		r0 = rf(ctx, ns)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, NamespaceRequest) error); ok {
		r1 = rf(ctx, ns)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockReadOnlyStore_CountFlags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountFlags'
type MockReadOnlyStore_CountFlags_Call struct {
	*mock.Call
}

// CountFlags is a helper method to define mock.On call
//   - ctx context.Context
//   - ns NamespaceRequest
func (_e *MockReadOnlyStore_Expecter) CountFlags(ctx interface{}, ns interface{}) *MockReadOnlyStore_CountFlags_Call {
	return &MockReadOnlyStore_CountFlags_Call{Call: _e.mock.On("CountFlags", ctx, ns)}
}

func (_c *MockReadOnlyStore_CountFlags_Call) Run(run func(ctx context.Context, ns NamespaceRequest)) *MockReadOnlyStore_CountFlags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(NamespaceRequest))
	})
	return _c
}

func (_c *MockReadOnlyStore_CountFlags_Call) Return(_a0 uint64, _a1 error) *MockReadOnlyStore_CountFlags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockReadOnlyStore_CountFlags_Call) RunAndReturn(run func(context.Context, NamespaceRequest) (uint64, error)) *MockReadOnlyStore_CountFlags_Call {
	_c.Call.Return(run)
	return _c
}

// EvaluationNamespaceSnapshot provides a mock function with given fields: _a0, ns
func (_m *MockReadOnlyStore) EvaluationNamespaceSnapshot(_a0 context.Context, ns string) (*evaluation.EvaluationNamespaceSnapshot, error) {
	ret := _m.Called(_a0, ns)

	if len(ret) == 0 {
		panic("no return value specified for EvaluationNamespaceSnapshot")
	}

	var r0 *evaluation.EvaluationNamespaceSnapshot
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*evaluation.EvaluationNamespaceSnapshot, error)); ok {
		return rf(_a0, ns)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *evaluation.EvaluationNamespaceSnapshot); ok {
		r0 = rf(_a0, ns)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*evaluation.EvaluationNamespaceSnapshot)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(_a0, ns)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockReadOnlyStore_EvaluationNamespaceSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EvaluationNamespaceSnapshot'
type MockReadOnlyStore_EvaluationNamespaceSnapshot_Call struct {
	*mock.Call
}

// EvaluationNamespaceSnapshot is a helper method to define mock.On call
//   - _a0 context.Context
//   - ns string
func (_e *MockReadOnlyStore_Expecter) EvaluationNamespaceSnapshot(_a0 interface{}, ns interface{}) *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call {
	return &MockReadOnlyStore_EvaluationNamespaceSnapshot_Call{Call: _e.mock.On("EvaluationNamespaceSnapshot", _a0, ns)}
}

func (_c *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call) Run(run func(_a0 context.Context, ns string)) *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call) Return(_a0 *evaluation.EvaluationNamespaceSnapshot, _a1 error) *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call) RunAndReturn(run func(context.Context, string) (*evaluation.EvaluationNamespaceSnapshot, error)) *MockReadOnlyStore_EvaluationNamespaceSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// GetEvaluationDistributions provides a mock function with given fields: ctx, flag, rule
func (_m *MockReadOnlyStore) GetEvaluationDistributions(ctx context.Context, flag ResourceRequest, rule IDRequest) ([]*EvaluationDistribution, error) {
	ret := _m.Called(ctx, flag, rule)

	if len(ret) == 0 {
		panic("no return value specified for GetEvaluationDistributions")
	}

	var r0 []*EvaluationDistribution
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ResourceRequest, IDRequest) ([]*EvaluationDistribution, error)); ok {
		return rf(ctx, flag, rule)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ResourceRequest, IDRequest) []*EvaluationDistribution); ok {
		r0 = rf(ctx, flag, rule)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*EvaluationDistribution)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ResourceRequest, IDRequest) error); ok {
		r1 = rf(ctx, flag, rule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockReadOnlyStore_GetEvaluationDistributions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEvaluationDistributions'
type MockReadOnlyStore_GetEvaluationDistributions_Call struct {
	*mock.Call
}

// GetEvaluationDistributions is a helper method to define mock.On call
//   - ctx context.Context
//   - flag ResourceRequest
//   - rule IDRequest
func (_e *MockReadOnlyStore_Expecter) GetEvaluationDistributions(ctx interface{}, flag interface{}, rule interface{}) *MockReadOnlyStore_GetEvaluationDistributions_Call {
	return &MockReadOnlyStore_GetEvaluationDistributions_Call{Call: _e.mock.On("GetEvaluationDistributions", ctx, flag, rule)}
}

func (_c *MockReadOnlyStore_GetEvaluationDistributions_Call) Run(run func(ctx context.Context, flag ResourceRequest, rule IDRequest)) *MockReadOnlyStore_GetEvaluationDistributions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ResourceRequest), args[2].(IDRequest))
	})
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationDistributions_Call) Return(_a0 []*EvaluationDistribution, _a1 error) *MockReadOnlyStore_GetEvaluationDistributions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationDistributions_Call) RunAndReturn(run func(context.Context, ResourceRequest, IDRequest) ([]*EvaluationDistribution, error)) *MockReadOnlyStore_GetEvaluationDistributions_Call {
	_c.Call.Return(run)
	return _c
}

// GetEvaluationRollouts provides a mock function with given fields: ctx, flag
func (_m *MockReadOnlyStore) GetEvaluationRollouts(ctx context.Context, flag ResourceRequest) ([]*EvaluationRollout, error) {
	ret := _m.Called(ctx, flag)

	if len(ret) == 0 {
		panic("no return value specified for GetEvaluationRollouts")
	}

	var r0 []*EvaluationRollout
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ResourceRequest) ([]*EvaluationRollout, error)); ok {
		return rf(ctx, flag)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ResourceRequest) []*EvaluationRollout); ok {
		r0 = rf(ctx, flag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*EvaluationRollout)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ResourceRequest) error); ok {
		r1 = rf(ctx, flag)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockReadOnlyStore_GetEvaluationRollouts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEvaluationRollouts'
type MockReadOnlyStore_GetEvaluationRollouts_Call struct {
	*mock.Call
}

// GetEvaluationRollouts is a helper method to define mock.On call
//   - ctx context.Context
//   - flag ResourceRequest
func (_e *MockReadOnlyStore_Expecter) GetEvaluationRollouts(ctx interface{}, flag interface{}) *MockReadOnlyStore_GetEvaluationRollouts_Call {
	return &MockReadOnlyStore_GetEvaluationRollouts_Call{Call: _e.mock.On("GetEvaluationRollouts", ctx, flag)}
}

func (_c *MockReadOnlyStore_GetEvaluationRollouts_Call) Run(run func(ctx context.Context, flag ResourceRequest)) *MockReadOnlyStore_GetEvaluationRollouts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ResourceRequest))
	})
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationRollouts_Call) Return(_a0 []*EvaluationRollout, _a1 error) *MockReadOnlyStore_GetEvaluationRollouts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationRollouts_Call) RunAndReturn(run func(context.Context, ResourceRequest) ([]*EvaluationRollout, error)) *MockReadOnlyStore_GetEvaluationRollouts_Call {
	_c.Call.Return(run)
	return _c
}

// GetEvaluationRules provides a mock function with given fields: ctx, flag
func (_m *MockReadOnlyStore) GetEvaluationRules(ctx context.Context, flag ResourceRequest) ([]*EvaluationRule, error) {
	ret := _m.Called(ctx, flag)

	if len(ret) == 0 {
		panic("no return value specified for GetEvaluationRules")
	}

	var r0 []*EvaluationRule
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ResourceRequest) ([]*EvaluationRule, error)); ok {
		return rf(ctx, flag)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ResourceRequest) []*EvaluationRule); ok {
		r0 = rf(ctx, flag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*EvaluationRule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ResourceRequest) error); ok {
		r1 = rf(ctx, flag)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockReadOnlyStore_GetEvaluationRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEvaluationRules'
type MockReadOnlyStore_GetEvaluationRules_Call struct {
	*mock.Call
}

// GetEvaluationRules is a helper method to define mock.On call
//   - ctx context.Context
//   - flag ResourceRequest
func (_e *MockReadOnlyStore_Expecter) GetEvaluationRules(ctx interface{}, flag interface{}) *MockReadOnlyStore_GetEvaluationRules_Call {
	return &MockReadOnlyStore_GetEvaluationRules_Call{Call: _e.mock.On("GetEvaluationRules", ctx, flag)}
}

func (_c *MockReadOnlyStore_GetEvaluationRules_Call) Run(run func(ctx context.Context, flag ResourceRequest)) *MockReadOnlyStore_GetEvaluationRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ResourceRequest))
	})
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationRules_Call) Return(_a0 []*EvaluationRule, _a1 error) *MockReadOnlyStore_GetEvaluationRules_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockReadOnlyStore_GetEvaluationRules_Call) RunAndReturn(run func(context.Context, ResourceRequest) ([]*EvaluationRule, error)) *MockReadOnlyStore_GetEvaluationRules_Call {
	_c.Call.Return(run)
	return _c
}

// GetFlag provides a mock function with given fields: ctx, req
func (_m *MockReadOnlyStore) GetFlag(ctx context.Context, req ResourceRequest) (*core.Flag, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetFlag")
	}

	var r0 *core.Flag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ResourceRequest) (*core.Flag, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ResourceRequest) *core.Flag); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Flag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ResourceRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockReadOnlyStore_GetFlag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFlag'
type MockReadOnlyStore_GetFlag_Call struct {
	*mock.Call
}

// GetFlag is a helper method to define mock.On call
//   - ctx context.Context
//   - req ResourceRequest
func (_e *MockReadOnlyStore_Expecter) GetFlag(ctx interface{}, req interface{}) *MockReadOnlyStore_GetFlag_Call {
	return &MockReadOnlyStore_GetFlag_Call{Call: _e.mock.On("GetFlag", ctx, req)}
}

func (_c *MockReadOnlyStore_GetFlag_Call) Run(run func(ctx context.Context, req ResourceRequest)) *MockReadOnlyStore_GetFlag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ResourceRequest))
	})
	return _c
}

func (_c *MockReadOnlyStore_GetFlag_Call) Return(_a0 *core.Flag, _a1 error) *MockReadOnlyStore_GetFlag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockReadOnlyStore_GetFlag_Call) RunAndReturn(run func(context.Context, ResourceRequest) (*core.Flag, error)) *MockReadOnlyStore_GetFlag_Call {
	_c.Call.Return(run)
	return _c
}

// ListFlags provides a mock function with given fields: ctx, req
func (_m *MockReadOnlyStore) ListFlags(ctx context.Context, req *ListRequest[NamespaceRequest]) (ResultSet[*core.Flag], error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ListFlags")
	}

	var r0 ResultSet[*core.Flag]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ListRequest[NamespaceRequest]) (ResultSet[*core.Flag], error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ListRequest[NamespaceRequest]) ResultSet[*core.Flag]); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Get(0).(ResultSet[*core.Flag])
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ListRequest[NamespaceRequest]) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockReadOnlyStore_ListFlags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListFlags'
type MockReadOnlyStore_ListFlags_Call struct {
	*mock.Call
}

// ListFlags is a helper method to define mock.On call
//   - ctx context.Context
//   - req *ListRequest[NamespaceRequest]
func (_e *MockReadOnlyStore_Expecter) ListFlags(ctx interface{}, req interface{}) *MockReadOnlyStore_ListFlags_Call {
	return &MockReadOnlyStore_ListFlags_Call{Call: _e.mock.On("ListFlags", ctx, req)}
}

func (_c *MockReadOnlyStore_ListFlags_Call) Run(run func(ctx context.Context, req *ListRequest[NamespaceRequest])) *MockReadOnlyStore_ListFlags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ListRequest[NamespaceRequest]))
	})
	return _c
}

func (_c *MockReadOnlyStore_ListFlags_Call) Return(_a0 ResultSet[*core.Flag], _a1 error) *MockReadOnlyStore_ListFlags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockReadOnlyStore_ListFlags_Call) RunAndReturn(run func(context.Context, *ListRequest[NamespaceRequest]) (ResultSet[*core.Flag], error)) *MockReadOnlyStore_ListFlags_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function with no fields
func (_m *MockReadOnlyStore) String() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockReadOnlyStore_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type MockReadOnlyStore_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *MockReadOnlyStore_Expecter) String() *MockReadOnlyStore_String_Call {
	return &MockReadOnlyStore_String_Call{Call: _e.mock.On("String")}
}

func (_c *MockReadOnlyStore_String_Call) Run(run func()) *MockReadOnlyStore_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockReadOnlyStore_String_Call) Return(_a0 string) *MockReadOnlyStore_String_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockReadOnlyStore_String_Call) RunAndReturn(run func() string) *MockReadOnlyStore_String_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReadOnlyStore creates a new instance of MockReadOnlyStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReadOnlyStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReadOnlyStore {
	mock := &MockReadOnlyStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
