// Code generated by protoc-gen-go-flipt-sdk. DO NOT EDIT.

package sdk

import (
	context "context"

	flipt "go.flipt.io/flipt/rpc/flipt"
	metadata "google.golang.org/grpc/metadata"
)

type Flipt struct {
	transport     flipt.FliptClient
	tokenProvider ClientTokenProvider
}

func (x *Flipt) Evaluate(ctx context.Context, v *flipt.EvaluationRequest) (*flipt.EvaluationResponse, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.Evaluate(ctx, v)
}

func (x *Flipt) BatchEvaluate(ctx context.Context, v *flipt.BatchEvaluationRequest) (*flipt.BatchEvaluationResponse, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.BatchEvaluate(ctx, v)
}

func (x *Flipt) GetFlag(ctx context.Context, v *flipt.GetFlagRequest) (*flipt.Flag, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.GetFlag(ctx, v)
}

func (x *Flipt) ListFlags(ctx context.Context, v *flipt.ListFlagRequest) (*flipt.FlagList, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.ListFlags(ctx, v)
}

func (x *Flipt) CreateFlag(ctx context.Context, v *flipt.CreateFlagRequest) (*flipt.Flag, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.CreateFlag(ctx, v)
}

func (x *Flipt) UpdateFlag(ctx context.Context, v *flipt.UpdateFlagRequest) (*flipt.Flag, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.UpdateFlag(ctx, v)
}

func (x *Flipt) DeleteFlag(ctx context.Context, v *flipt.DeleteFlagRequest) error {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	_, err := x.transport.DeleteFlag(ctx, v)
	return err
}

func (x *Flipt) CreateVariant(ctx context.Context, v *flipt.CreateVariantRequest) (*flipt.Variant, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.CreateVariant(ctx, v)
}

func (x *Flipt) UpdateVariant(ctx context.Context, v *flipt.UpdateVariantRequest) (*flipt.Variant, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.UpdateVariant(ctx, v)
}

func (x *Flipt) DeleteVariant(ctx context.Context, v *flipt.DeleteVariantRequest) error {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	_, err := x.transport.DeleteVariant(ctx, v)
	return err
}

func (x *Flipt) GetRule(ctx context.Context, v *flipt.GetRuleRequest) (*flipt.Rule, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.GetRule(ctx, v)
}

func (x *Flipt) ListRules(ctx context.Context, v *flipt.ListRuleRequest) (*flipt.RuleList, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.ListRules(ctx, v)
}

func (x *Flipt) CreateRule(ctx context.Context, v *flipt.CreateRuleRequest) (*flipt.Rule, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.CreateRule(ctx, v)
}

func (x *Flipt) UpdateRule(ctx context.Context, v *flipt.UpdateRuleRequest) (*flipt.Rule, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.UpdateRule(ctx, v)
}

func (x *Flipt) OrderRules(ctx context.Context, v *flipt.OrderRulesRequest) error {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	_, err := x.transport.OrderRules(ctx, v)
	return err
}

func (x *Flipt) DeleteRule(ctx context.Context, v *flipt.DeleteRuleRequest) error {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	_, err := x.transport.DeleteRule(ctx, v)
	return err
}

func (x *Flipt) CreateDistribution(ctx context.Context, v *flipt.CreateDistributionRequest) (*flipt.Distribution, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.CreateDistribution(ctx, v)
}

func (x *Flipt) UpdateDistribution(ctx context.Context, v *flipt.UpdateDistributionRequest) (*flipt.Distribution, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.UpdateDistribution(ctx, v)
}

func (x *Flipt) DeleteDistribution(ctx context.Context, v *flipt.DeleteDistributionRequest) error {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	_, err := x.transport.DeleteDistribution(ctx, v)
	return err
}

func (x *Flipt) GetSegment(ctx context.Context, v *flipt.GetSegmentRequest) (*flipt.Segment, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.GetSegment(ctx, v)
}

func (x *Flipt) ListSegments(ctx context.Context, v *flipt.ListSegmentRequest) (*flipt.SegmentList, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.ListSegments(ctx, v)
}

func (x *Flipt) CreateSegment(ctx context.Context, v *flipt.CreateSegmentRequest) (*flipt.Segment, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.CreateSegment(ctx, v)
}

func (x *Flipt) UpdateSegment(ctx context.Context, v *flipt.UpdateSegmentRequest) (*flipt.Segment, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.UpdateSegment(ctx, v)
}

func (x *Flipt) DeleteSegment(ctx context.Context, v *flipt.DeleteSegmentRequest) error {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	_, err := x.transport.DeleteSegment(ctx, v)
	return err
}

func (x *Flipt) CreateConstraint(ctx context.Context, v *flipt.CreateConstraintRequest) (*flipt.Constraint, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.CreateConstraint(ctx, v)
}

func (x *Flipt) UpdateConstraint(ctx context.Context, v *flipt.UpdateConstraintRequest) (*flipt.Constraint, error) {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return nil, err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	return x.transport.UpdateConstraint(ctx, v)
}

func (x *Flipt) DeleteConstraint(ctx context.Context, v *flipt.DeleteConstraintRequest) error {
	if x.tokenProvider != nil {
		token, err := x.tokenProvider.ClientToken()
		if err != nil {
			return err
		}

		ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
	}

	_, err := x.transport.DeleteConstraint(ctx, v)
	return err
}
